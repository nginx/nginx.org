<?xml version="1.0"?>

<!--
  Copyright (C) Igor Sysoev
  Copyright (C) Nginx, Inc.
  -->

<!DOCTYPE module SYSTEM "../../../../dtd/module.dtd">

<module name="Module ngx_http_proxy_module"
        link="/en/docs/http/ngx_http_proxy_module.html"
        lang="en"
        rev="78">

<section id="summary">

<para>
The <literal>ngx_http_proxy_module</literal> module allows passing
requests to another server.
</para>

</section>


<section id="example" name="Example Configuration">

<para>
<example>
location / {
    proxy_pass       http://localhost:8000;
    proxy_set_header Host      $host;
    proxy_set_header X-Real-IP $remote_addr;
}
</example>
</para>

</section>


<section id="directives" name="Directives">

<directive name="proxy_bind">
<syntax>
    <value>address</value>
    [<literal>transparent</literal>] |
    <literal>off</literal></syntax>
<default/>
<context>http</context>
<context>server</context>
<context>location</context>
<appeared-in>0.8.22</appeared-in>

<para>
Makes outgoing connections to a proxied server originate
from the specified local IP address with an optional port (1.11.2).
Parameter value can contain variables (1.3.12).
The special value <literal>off</literal> (1.3.12) cancels the effect
of the <literal>proxy_bind</literal> directive
inherited from the previous configuration level, which allows the
system to auto-assign the local IP address and port.
</para>

<para id="proxy_bind_transparent">
The <literal>transparent</literal> parameter (1.11.0) allows
outgoing connections to a proxied server originate
from a non-local IP address,
for example, from a real IP address of a client:
<example>
proxy_bind $remote_addr transparent;
</example>
In order for this parameter to work,
it is usually necessary to run nginx worker processes with the
<link doc="../ngx_core_module.xml" id="user">superuser</link> privileges.
On Linux it is not required (1.13.8) as if
the <literal>transparent</literal> parameter is specified, worker processes
inherit the <literal>CAP_NET_RAW</literal> capability from the master process.
It is also necessary to configure kernel routing table
to intercept network traffic from the proxied server.
</para>

</directive>


<directive name="proxy_buffer_size">
<syntax><value>size</value></syntax>
<default>4k|8k</default>
<context>http</context>
<context>server</context>
<context>location</context>

<para>
Sets the <value>size</value> of the buffer used for reading the first part
of the response received from the proxied server.
This part usually contains a small response header.
By default, the buffer size is equal to one memory page.
This is either 4K or 8K, depending on a platform.
It can be made smaller, however.
</para>

</directive>


<directive name="proxy_buffering">
<syntax><literal>on</literal> | <literal>off</literal></syntax>
<default>on</default>
<context>http</context>
<context>server</context>
<context>location</context>

<para>
Enables or disables buffering of responses from the proxied server.
</para>

<para>
When buffering is enabled, nginx receives a response from the proxied server
as soon as possible, saving it into the buffers set by the
<link id="proxy_buffer_size"/> and <link id="proxy_buffers"/> directives.
If the whole response does not fit into memory, a part of it can be saved
to a <link id="proxy_temp_path">temporary file</link> on the disk.
Writing to temporary files is controlled by the
<link id="proxy_max_temp_file_size"/> and
<link id="proxy_temp_file_write_size"/> directives.
</para>

<para>
When buffering is disabled, the response is passed to a client synchronously,
immediately as it is received.
nginx will not try to read the whole response from the proxied server.
The maximum size of the data that nginx can receive from the server
at a time is set by the <link id="proxy_buffer_size"/> directive.
</para>

<para>
Buffering can also be enabled or disabled by passing
“<literal>yes</literal>” or “<literal>no</literal>” in the
<header>X-Accel-Buffering</header> response header field.
This capability can be disabled using the
<link id="proxy_ignore_headers"/> directive.
</para>

</directive>


<directive name="proxy_buffers">
<syntax><value>number</value> <value>size</value></syntax>
<default>8 4k|8k</default>
<context>http</context>
<context>server</context>
<context>location</context>

<para>
Sets the <value>number</value> and <value>size</value> of the
buffers used for reading a response from the proxied server,
for a single connection.
By default, the buffer size is equal to one memory page.
This is either 4K or 8K, depending on a platform.
</para>

</directive>


<directive name="proxy_busy_buffers_size">
<syntax><value>size</value></syntax>
<default>8k|16k</default>
<context>http</context>
<context>server</context>
<context>location</context>

<para>
When <link id="proxy_buffering">buffering</link> of responses from the proxied
server is enabled, limits the total <value>size</value> of buffers that
can be busy sending a response to the client while the response is not
yet fully read.
In the meantime, the rest of the buffers can be used for reading the response
and, if needed, buffering part of the response to a temporary file.
By default, <value>size</value> is limited by the size of two buffers set by the
<link id="proxy_buffer_size"/> and <link id="proxy_buffers"/> directives.
</para>

</directive>


<directive name="proxy_cache">
<syntax><value>zone</value> | <literal>off</literal></syntax>
<default>off</default>
<context>http</context>
<context>server</context>
<context>location</context>

<para>
Defines a shared memory zone used for caching.
The same zone can be used in several places.
Parameter value can contain variables (1.7.9).
The <literal>off</literal> parameter disables caching inherited
from the previous configuration level.
</para>

</directive>


<directive name="proxy_cache_background_update">
<syntax><literal>on</literal> | <literal>off</literal></syntax>
<default>off</default>
<context>http</context>
<context>server</context>
<context>location</context>
<appeared-in>1.11.10</appeared-in>

<para>
Allows starting a background subrequest
to update an expired cache item,
while a stale cached response is returned to the client.
Note that it is necessary to
<link id="proxy_cache_use_stale_updating">allow</link>
the usage of a stale cached response when it is being updated.
</para>

</directive>


<directive name="proxy_cache_bypass">
<syntax><value>string</value> ...</syntax>
<default/>
<context>http</context>
<context>server</context>
<context>location</context>

<para>
Defines conditions under which the response will not be taken from a cache.
If at least one value of the string parameters is not empty and is not
equal to “0” then the response will not be taken from the cache:
<example>
proxy_cache_bypass $cookie_nocache $arg_nocache$arg_comment;
proxy_cache_bypass $http_pragma    $http_authorization;
</example>
Can be used along with the <link id="proxy_no_cache"/> directive.
</para>

</directive>

<directive name="proxy_cache_convert_head">
<syntax><literal>on</literal> | <literal>off</literal></syntax>
<default>on</default>
<context>http</context>
<context>server</context>
<context>location</context>
<appeared-in>1.9.7</appeared-in>

<para>
Enables or disables the conversion of the “<literal>HEAD</literal>” method
to “<literal>GET</literal>” for caching.
When the conversion is disabled, the
<link id="proxy_cache_key">cache key</link> should be configured
to include the <var>$request_method</var>.
</para>

</directive>


<directive name="proxy_cache_key">
<syntax><value>string</value></syntax>
<default>$scheme$proxy_host$request_uri</default>
<context>http</context>
<context>server</context>
<context>location</context>

<para>
Defines a key for caching, for example
<example>
proxy_cache_key "$host$request_uri $cookie_user";
</example>
By default, the directive’s value is close to the string
<example>
proxy_cache_key $scheme$proxy_host$uri$is_args$args;
</example>
</para>

</directive>


<directive name="proxy_cache_lock">
<syntax><literal>on</literal> | <literal>off</literal></syntax>
<default>off</default>
<context>http</context>
<context>server</context>
<context>location</context>
<appeared-in>1.1.12</appeared-in>

<para>
When enabled, only one request at a time will be allowed to populate
a new cache element identified according to the <link id="proxy_cache_key"/>
directive by passing a request to a proxied server.
Other requests of the same cache element will either wait
for a response to appear in the cache or the cache lock for
this element to be released, up to the time set by the
<link id="proxy_cache_lock_timeout"/> directive.
</para>

</directive>


<directive name="proxy_cache_lock_age">
<syntax><value>time</value></syntax>
<default>5s</default>
<context>http</context>
<context>server</context>
<context>location</context>
<appeared-in>1.7.8</appeared-in>

<para>
If the last request passed to the proxied server
for populating a new cache element
has not completed for the specified <value>time</value>,
one more request may be passed to the proxied server.
</para>

</directive>


<directive name="proxy_cache_lock_timeout">
<syntax><value>time</value></syntax>
<default>5s</default>
<context>http</context>
<context>server</context>
<context>location</context>
<appeared-in>1.1.12</appeared-in>

<para>
Sets a timeout for <link id="proxy_cache_lock"/>.
When the <value>time</value> expires,
the request will be passed to the proxied server,
however, the response will not be cached.
<note>
Before 1.7.8, the response could be cached.
</note>
</para>

</directive>


<directive name="proxy_cache_max_range_offset">
<syntax><value>number</value></syntax>
<default/>
<context>http</context>
<context>server</context>
<context>location</context>
<appeared-in>1.11.6</appeared-in>

<para>
Sets an offset in bytes for byte-range requests.
If the range is beyond the offset,
the range request will be passed to the proxied server
and the response will not be cached.
</para>

</directive>


<directive name="proxy_cache_methods">
<syntax>
    <literal>GET</literal> |
    <literal>HEAD</literal> |
    <literal>POST</literal>
    ...</syntax>
<default>GET HEAD</default>
<context>http</context>
<context>server</context>
<context>location</context>
<appeared-in>0.7.59</appeared-in>

<para>
If the client request method is listed in this directive then
the response will be cached.
“<literal>GET</literal>” and “<literal>HEAD</literal>” methods are always
added to the list, though it is recommended to specify them explicitly.
See also the <link id="proxy_no_cache"/> directive.
</para>

</directive>


<directive name="proxy_cache_min_uses">
<syntax><value>number</value></syntax>
<default>1</default>
<context>http</context>
<context>server</context>
<context>location</context>

<para>
Sets the <value>number</value> of requests after which the response
will be cached.
</para>

</directive>


<directive name="proxy_cache_path">
<syntax>
    <value>path</value>
    [<literal>levels</literal>=<value>levels</value>]
    [<literal>use_temp_path</literal>=<literal>on</literal>|<literal>off</literal>]
    <literal>keys_zone</literal>=<value>name</value>:<value>size</value>
    [<literal>inactive</literal>=<value>time</value>]
    [<literal>max_size</literal>=<value>size</value>]
    [<literal>min_free</literal>=<value>size</value>]
    [<literal>manager_files</literal>=<value>number</value>]
    [<literal>manager_sleep</literal>=<value>time</value>]
    [<literal>manager_threshold</literal>=<value>time</value>]
    [<literal>loader_files</literal>=<value>number</value>]
    [<literal>loader_sleep</literal>=<value>time</value>]
    [<literal>loader_threshold</literal>=<value>time</value>]
    [<literal>purger</literal>=<literal>on</literal>|<literal>off</literal>]
    [<literal>purger_files</literal>=<value>number</value>]
    [<literal>purger_sleep</literal>=<value>time</value>]
    [<literal>purger_threshold</literal>=<value>time</value>]</syntax>
<default/>
<context>http</context>

<para>
Sets the path and other parameters of a cache.
Cache data are stored in files.
The file name in a cache is a result of
applying the MD5 function to the
<link id="proxy_cache_key">cache key</link>.
The <literal>levels</literal> parameter defines hierarchy levels of a cache:
from 1 to 3, each level accepts values 1 or 2.
For example, in the following configuration
<example>
proxy_cache_path /data/nginx/cache levels=1:2 keys_zone=one:10m;
</example>
file names in a cache will look like this:
<example>
/data/nginx/cache/<emphasis>c</emphasis>/<emphasis>29</emphasis>/b7f54b2df7773722d382f4809d650<emphasis>29c</emphasis>
</example>
</para>

<para>
A cached response is first written to a temporary file,
and then the file is renamed.
Starting from version 0.8.9, temporary files and the cache can be put on
different file systems.
However, be aware that in this case a file is copied
across two file systems instead of the cheap renaming operation.
It is thus recommended that for any given location both cache and a directory
holding temporary files
are put on the same file system.
The directory for temporary files is set based on
the <literal>use_temp_path</literal> parameter (1.7.10).
If this parameter is omitted or set to the value <literal>on</literal>,
the directory set by the <link id="proxy_temp_path"/> directive
for the given location will be used.
If the value is set to <literal>off</literal>,
temporary files will be put directly in the cache directory.
</para>

<para>
In addition, all active keys and information about data are stored
in a shared memory zone, whose <value>name</value> and <value>size</value>
are configured by the <literal>keys_zone</literal> parameter.
One megabyte zone can store about 8 thousand keys.
<note>
As part of
<commercial_version>commercial subscription</commercial_version>,
the shared memory zone also stores extended
cache <link doc="ngx_http_api_module.xml" id="http_caches_">information</link>,
thus, it is required to specify a larger zone size for the same number of keys.
For example,
one megabyte zone can store about 4 thousand keys.
</note>
</para>

<para>
Cached data that are not accessed during the time specified by the
<literal>inactive</literal> parameter get removed from the cache
regardless of their freshness.
By default, <literal>inactive</literal> is set to 10 minutes.
</para>

<para id="proxy_cache_path_max_size">
The special “cache manager” process monitors the maximum cache size set
by the <literal>max_size</literal> parameter,
and the minimum amount of free space set
by the <literal>min_free</literal> (1.19.1) parameter
on the file system with cache.
When the size is exceeded or there is not enough free space,
it removes the least recently used data.
The data is removed in iterations configured by
<literal>manager_files</literal>,
<literal>manager_threshold</literal>, and
<literal>manager_sleep</literal> parameters (1.11.5).
During one iteration no more than <literal>manager_files</literal> items
are deleted (by default, 100).
The duration of one iteration is limited by the
<literal>manager_threshold</literal> parameter (by default, 200 milliseconds).
Between iterations, a pause configured by the <literal>manager_sleep</literal>
parameter (by default, 50 milliseconds) is made.
</para>

<para>
A minute after the start the special “cache loader” process is activated.
It loads information about previously cached data stored on file system
into a cache zone.
The loading is also done in iterations.
During one iteration no more than <literal>loader_files</literal> items
are loaded (by default, 100).
Besides, the duration of one iteration is limited by the
<literal>loader_threshold</literal> parameter (by default, 200 milliseconds).
Between iterations, a pause configured by the <literal>loader_sleep</literal>
parameter (by default, 50 milliseconds) is made.
</para>

<para>
Additionally,
the following parameters are available as part of our
<commercial_version>commercial subscription</commercial_version>:
</para>

<para>
<list type="tag">

<tag-name id="purger">
<literal>purger</literal>=<literal>on</literal>|<literal>off</literal>
</tag-name>
<tag-desc>
Instructs whether cache entries that match a
<link id="proxy_cache_purge">wildcard key</link>
will be removed from the disk by the cache purger (1.7.12).
Setting the parameter to <literal>on</literal>
(default is <literal>off</literal>)
will activate the “cache purger” process that
permanently iterates through all cache entries
and deletes the entries that match the wildcard key.
</tag-desc>

<tag-name id="purger_files">
<literal>purger_files</literal>=<value>number</value>
</tag-name>
<tag-desc>
Sets the number of items that will be scanned during one iteration (1.7.12).
By default, <literal>purger_files</literal> is set to 10.
</tag-desc>

<tag-name id="purger_threshold">
<literal>purger_threshold</literal>=<value>number</value>
</tag-name>
<tag-desc>
Sets the duration of one iteration (1.7.12).
By default, <literal>purger_threshold</literal> is set to 50 milliseconds.
</tag-desc>

<tag-name id="purger_sleep">
<literal>purger_sleep</literal>=<value>number</value>
</tag-name>
<tag-desc>
Sets a pause between iterations (1.7.12).
By default, <literal>purger_sleep</literal> is set to 50 milliseconds.
</tag-desc>

</list>
</para>

<para>
<note>
In versions 1.7.3, 1.7.7, and 1.11.10 cache header format has been changed.
Previously cached responses will be considered invalid
after upgrading to a newer nginx version.
</note>
</para>

</directive>


<directive name="proxy_cache_purge">
<syntax>string ...</syntax>
<default/>
<context>http</context>
<context>server</context>
<context>location</context>
<appeared-in>1.5.7</appeared-in>

<para>
Defines conditions under which the request will be considered a cache
purge request.
If at least one value of the string parameters is not empty and is not equal
to “0” then the cache entry with a corresponding
<link id="proxy_cache_key">cache key</link> is removed.
The result of successful operation is indicated by returning
the <http-status code="204" text="No Content"/> response.
</para>

<para>
If the <link id="proxy_cache_key">cache key</link> of a purge request ends
with an asterisk (“<literal>*</literal>”), all cache entries matching the
wildcard key will be removed from the cache.
However, these entries will remain on the disk until they are deleted
for either <link id="proxy_cache_path">inactivity</link>,
or processed by the <link id="purger">cache purger</link> (1.7.12),
or a client attempts to access them.
</para>

<para>
Example configuration:
<example>
proxy_cache_path /data/nginx/cache keys_zone=cache_zone:10m;

map $request_method $purge_method {
    PURGE   1;
    default 0;
}

server {
    ...
    location / {
        proxy_pass http://backend;
        proxy_cache cache_zone;
        proxy_cache_key $uri;
        proxy_cache_purge $purge_method;
    }
}
</example>
<note>
This functionality is available as part of our
<commercial_version>commercial subscription</commercial_version>.
</note>
</para>

</directive>


<directive name="proxy_cache_revalidate">
<syntax><literal>on</literal> | <literal>off</literal></syntax>
<default>off</default>
<context>http</context>
<context>server</context>
<context>location</context>
<appeared-in>1.5.7</appeared-in>

<para>
Enables revalidation of expired cache items using conditional requests with
the <header>If-Modified-Since</header> and <header>If-None-Match</header>
header fields.
</para>

</directive>


<directive name="proxy_cache_use_stale">
<syntax>
    <literal>error</literal> |
    <literal>timeout</literal> |
    <literal>invalid_header</literal> |
    <literal>updating</literal> |
    <literal>http_500</literal> |
    <literal>http_502</literal> |
    <literal>http_503</literal> |
    <literal>http_504</literal> |
    <literal>http_403</literal> |
    <literal>http_404</literal> |
    <literal>http_429</literal> |
    <literal>off</literal>
    ...</syntax>
<default>off</default>
<context>http</context>
<context>server</context>
<context>location</context>

<para>
Determines in which cases a stale cached response can be used
during communication with the proxied server.
The directive’s parameters match the parameters of the
<link id="proxy_next_upstream"/> directive.
</para>

<para>
The <literal>error</literal> parameter also permits
using a stale cached response if a proxied server to process a request
cannot be selected.
</para>

<para id="proxy_cache_use_stale_updating">
Additionally, the <literal>updating</literal> parameter permits
using a stale cached response if it is currently being updated.
This allows minimizing the number of accesses to proxied servers
when updating cached data.
</para>

<para>
Using a stale cached response
can also be enabled directly in the response header
for a specified number of seconds after the response became stale (1.11.10).
This has lower priority than using the directive parameters.
<list type="bullet" compact="no">

<listitem>
The
“<link url="https://datatracker.ietf.org/doc/html/rfc5861#section-3">stale-while-revalidate</link>”
extension of the <header>Cache-Control</header> header field permits
using a stale cached response if it is currently being updated.
</listitem>

<listitem>
The
“<link url="https://datatracker.ietf.org/doc/html/rfc5861#section-4">stale-if-error</link>”
extension of the <header>Cache-Control</header> header field permits
using a stale cached response in case of an error.
</listitem>

</list>
</para>

<para>
To minimize the number of accesses to proxied servers when
populating a new cache element, the <link id="proxy_cache_lock"/>
directive can be used.
</para>

</directive>


<directive name="proxy_cache_valid">
<syntax>[<value>code</value> ...] <value>time</value></syntax>
<default/>
<context>http</context>
<context>server</context>
<context>location</context>

<para>
Sets caching time for different response codes.
For example, the following directives
<example>
proxy_cache_valid 200 302 10m;
proxy_cache_valid 404      1m;
</example>
set 10 minutes of caching for responses with codes 200 and 302
and 1 minute for responses with code 404.
</para>

<para>
If only caching <value>time</value> is specified
<example>
proxy_cache_valid 5m;
</example>
then only 200, 301, and 302 responses are cached.
</para>

<para>
In addition, the <literal>any</literal> parameter can be specified
to cache any responses:
<example>
proxy_cache_valid 200 302 10m;
proxy_cache_valid 301      1h;
proxy_cache_valid any      1m;
</example>
</para>

<para>
Parameters of caching can also be set directly
in the response header.
This has higher priority than setting of caching time using the directive.
<list type="bullet" compact="no">

<listitem>
The <header>X-Accel-Expires</header> header field sets caching time of a
response in seconds.
The zero value disables caching for a response.
If the value starts with the <literal>@</literal> prefix, it sets an absolute
time in seconds since Epoch, up to which the response may be cached.
</listitem>

<listitem>
If the header does not include the <header>X-Accel-Expires</header> field,
parameters of caching may be set in the header fields
<header>Expires</header> or <header>Cache-Control</header>.
</listitem>

<listitem>
If the header includes the <header>Set-Cookie</header> field, such a
response will not be cached.
</listitem>

<listitem>
If the header includes the <header>Vary</header> field
with the special value “<literal>*</literal>”, such a
response will not be cached (1.7.7).
If the header includes the <header>Vary</header> field
with another value, such a response will be cached
taking into account the corresponding request header fields (1.7.7).
</listitem>

</list>
Processing of one or more of these response header fields can be disabled
using the <link id="proxy_ignore_headers"/> directive.
</para>

</directive>


<directive name="proxy_connect_timeout">
<syntax><value>time</value></syntax>
<default>60s</default>
<context>http</context>
<context>server</context>
<context>location</context>

<para>
Defines a timeout for establishing a connection with a proxied server.
It should be noted that this timeout cannot usually exceed 75 seconds.
</para>

</directive>


<directive name="proxy_cookie_domain">
<syntax><literal>off</literal></syntax>
<syntax><value>domain</value> <value>replacement</value></syntax>
<default>off</default>
<context>http</context>
<context>server</context>
<context>location</context>
<appeared-in>1.1.15</appeared-in>

<para>
Sets a text that should be changed in the <literal>domain</literal>
attribute of the <header>Set-Cookie</header> header fields of a
proxied server response.
Suppose a proxied server returned the <header>Set-Cookie</header>
header field with the attribute
“<literal>domain=localhost</literal>”.
The directive
<example>
proxy_cookie_domain localhost example.org;
</example>
will rewrite this attribute to
“<literal>domain=example.org</literal>”.
</para>

<para>
A dot at the beginning of the <value>domain</value> and
<value>replacement</value> strings and the <literal>domain</literal>
attribute is ignored.
Matching is case-insensitive.
</para>

<para>
The <value>domain</value> and <value>replacement</value> strings
can contain variables:
<example>
proxy_cookie_domain www.$host $host;
</example>
</para>

<para>
The directive can also be specified using regular expressions.
In this case, <value>domain</value> should start from
the “<literal>~</literal>” symbol.
A regular expression can contain named and positional captures,
and <value>replacement</value> can reference them:
<example>
proxy_cookie_domain ~\.(?P&lt;sl_domain&gt;[-0-9a-z]+\.[a-z]+)$ $sl_domain;
</example>
</para>

<para>
Several <literal>proxy_cookie_domain</literal> directives
can be specified on the same level:
<example>
proxy_cookie_domain localhost example.org;
proxy_cookie_domain ~\.([a-z]+\.[a-z]+)$ $1;
</example>
If several directives can be applied to the cookie,
the first matching directive will be chosen.
</para>

<para>
The <literal>off</literal> parameter cancels the effect
of the <literal>proxy_cookie_domain</literal> directives
inherited from the previous configuration level.
</para>

</directive>


<directive name="proxy_cookie_flags">
<syntax>
    <literal>off</literal> |
    <value>cookie</value>
    [<value>flag</value> ...]</syntax>
<default>off</default>
<context>http</context>
<context>server</context>
<context>location</context>
<appeared-in>1.19.3</appeared-in>

<para>
Sets one or more flags for the cookie.
The <value>cookie</value> can contain text, variables, and their combinations.
The <value>flag</value>
can contain text, variables, and their combinations (1.19.8).
The
<literal>secure</literal>,
<literal>httponly</literal>,
<literal>samesite=strict</literal>,
<literal>samesite=lax</literal>,
<literal>samesite=none</literal>
parameters add the corresponding flags.
The
<literal>nosecure</literal>,
<literal>nohttponly</literal>,
<literal>nosamesite</literal>
parameters remove the corresponding flags.
</para>

<para>
The cookie can also be specified using regular expressions.
In this case, <value>cookie</value> should start from
the “<literal>~</literal>” symbol.
</para>

<para>
Several <literal>proxy_cookie_flags</literal> directives
can be specified on the same configuration level:
<example>
proxy_cookie_flags one httponly;
proxy_cookie_flags ~ nosecure samesite=strict;
</example>
If several directives can be applied to the cookie,
the first matching directive will be chosen.
In the example, the <literal>httponly</literal> flag
is added to the cookie <literal>one</literal>,
for all other cookies
the <literal>samesite=strict</literal> flag is added and
the <literal>secure</literal> flag is deleted.
</para>

<para>
The <literal>off</literal> parameter cancels the effect
of the <literal>proxy_cookie_flags</literal> directives
inherited from the previous configuration level.
</para>

</directive>


<directive name="proxy_cookie_path">
<syntax><literal>off</literal></syntax>
<syntax><value>path</value> <value>replacement</value></syntax>
<default>off</default>
<context>http</context>
<context>server</context>
<context>location</context>
<appeared-in>1.1.15</appeared-in>

<para>
Sets a text that should be changed in the <literal>path</literal>
attribute of the <header>Set-Cookie</header> header fields of a
proxied server response.
Suppose a proxied server returned the <header>Set-Cookie</header>
header field with the attribute
“<literal>path=/two/some/uri/</literal>”.
The directive
<example>
proxy_cookie_path /two/ /;
</example>
will rewrite this attribute to
“<literal>path=/some/uri/</literal>”.
</para>

<para>
The <value>path</value> and <value>replacement</value> strings
can contain variables:
<example>
proxy_cookie_path $uri /some$uri;
</example>
</para>

<para>
The directive can also be specified using regular expressions.
In this case, <value>path</value> should either start from
the “<literal>~</literal>” symbol for a case-sensitive matching,
or from the “<literal>~*</literal>” symbols for case-insensitive
matching.
The regular expression can contain named and positional captures,
and <value>replacement</value> can reference them:
<example>
proxy_cookie_path ~*^/user/([^/]+) /u/$1;
</example>
</para>

<para>
Several <literal>proxy_cookie_path</literal> directives
can be specified on the same level:
<example>
proxy_cookie_path /one/ /;
proxy_cookie_path / /two/;
</example>
If several directives can be applied to the cookie,
the first matching directive will be chosen.
</para>

<para>
The <literal>off</literal> parameter cancels the effect
of the <literal>proxy_cookie_path</literal> directives
inherited from the previous configuration level.
</para>

</directive>


<directive name="proxy_force_ranges">
<syntax><literal>on</literal> | <literal>off</literal></syntax>
<default>off</default>
<context>http</context>
<context>server</context>
<context>location</context>
<appeared-in>1.7.7</appeared-in>

<para>
Enables byte-range support
for both cached and uncached responses from the proxied server
regardless of the <header>Accept-Ranges</header> field in these responses.
</para>

</directive>


<directive name="proxy_headers_hash_bucket_size">
<syntax><value>size</value></syntax>
<default>64</default>
<context>http</context>
<context>server</context>
<context>location</context>

<para>
Sets the bucket <value>size</value> for hash tables
used by the <link id="proxy_hide_header"/> and <link id="proxy_set_header"/>
directives.
The details of setting up hash tables are provided in a separate
<link doc="../hash.xml">document</link>.
</para>

</directive>


<directive name="proxy_headers_hash_max_size">
<syntax><value>size</value></syntax>
<default>512</default>
<context>http</context>
<context>server</context>
<context>location</context>

<para>
Sets the maximum <value>size</value> of hash tables
used by the <link id="proxy_hide_header"/> and <link id="proxy_set_header"/>
directives.
The details of setting up hash tables are provided in a separate
<link doc="../hash.xml">document</link>.
</para>

</directive>


<directive name="proxy_hide_header">
<syntax><value>field</value></syntax>
<default/>
<context>http</context>
<context>server</context>
<context>location</context>

<para>
By default,
nginx does not pass the header fields <header>Date</header>,
<header>Server</header>, <header>X-Pad</header>, and
<header>X-Accel-...</header> from the response of a proxied
server to a client.
The <literal>proxy_hide_header</literal> directive sets additional fields
that will not be passed.
If, on the contrary, the passing of fields needs to be permitted,
the <link id="proxy_pass_header"/> directive can be used.
</para>

</directive>


<directive name="proxy_http_version">
<syntax><literal>1.0</literal> | <literal>1.1</literal></syntax>
<default>1.0</default>
<context>http</context>
<context>server</context>
<context>location</context>
<appeared-in>1.1.4</appeared-in>

<para>
Sets the HTTP protocol version for proxying.
By default, version 1.0 is used.
Version 1.1 is recommended for use with
<link doc="ngx_http_upstream_module.xml" id="keepalive"/>
connections and
<link doc="ngx_http_upstream_module.xml" id="ntlm">NTLM authentication</link>.
</para>

</directive>


<directive name="proxy_ignore_client_abort">
<syntax><literal>on</literal> | <literal>off</literal></syntax>
<default>off</default>
<context>http</context>
<context>server</context>
<context>location</context>

<para>
Determines whether the connection with a proxied server should be
closed when a client closes the connection without waiting
for a response.
</para>

</directive>


<directive name="proxy_ignore_headers">
<syntax><value>field</value> ...</syntax>
<default/>
<context>http</context>
<context>server</context>
<context>location</context>

<para>
Disables processing of certain response header fields from the proxied server.
The following fields can be ignored: <header>X-Accel-Redirect</header>,
<header>X-Accel-Expires</header>, <header>X-Accel-Limit-Rate</header> (1.1.6),
<header>X-Accel-Buffering</header> (1.1.6),
<header>X-Accel-Charset</header> (1.1.6), <header>Expires</header>,
<header>Cache-Control</header>, <header>Set-Cookie</header> (0.8.44),
and <header>Vary</header> (1.7.7).
</para>

<para>
If not disabled, processing of these header fields has the following
effect:
<list type="bullet" compact="no">

<listitem>
<header>X-Accel-Expires</header>, <header>Expires</header>,
<header>Cache-Control</header>, <header>Set-Cookie</header>,
and <header>Vary</header>
set the parameters of response <link id="proxy_cache_valid">caching</link>;
</listitem>

<listitem>
<header>X-Accel-Redirect</header> performs an
<link doc="ngx_http_core_module.xml" id="internal">internal
redirect</link> to the specified URI;
</listitem>

<listitem>
<header>X-Accel-Limit-Rate</header> sets the
<link doc="ngx_http_core_module.xml" id="limit_rate">rate
limit</link> for transmission of a response to a client;
</listitem>

<listitem>
<header>X-Accel-Buffering</header> enables or disables
<link id="proxy_buffering">buffering</link> of a response;
</listitem>

<listitem>
<header>X-Accel-Charset</header> sets the desired
<link doc="ngx_http_charset_module.xml" id="charset"/>
of a response.
</listitem>

</list>
</para>

</directive>


<directive name="proxy_intercept_errors">
<syntax><literal>on</literal> | <literal>off</literal></syntax>
<default>off</default>
<context>http</context>
<context>server</context>
<context>location</context>

<para>
Determines whether proxied responses with codes greater than or equal
to 300 should be passed to a client
or be intercepted and redirected to nginx for processing
with the <link doc="ngx_http_core_module.xml" id="error_page"/> directive.
</para>

</directive>


<directive name="proxy_limit_rate">
<syntax><value>rate</value></syntax>
<default>0</default>
<context>http</context>
<context>server</context>
<context>location</context>
<appeared-in>1.7.7</appeared-in>

<para>
Limits the speed of reading the response from the proxied server.
The <value>rate</value> is specified in bytes per second.
The zero value disables rate limiting.
The limit is set per a request, and so if nginx simultaneously opens
two connections to the proxied server,
the overall rate will be twice as much as the specified limit.
The limitation works only if
<link id="proxy_buffering">buffering</link> of responses from the proxied
server is enabled.
Parameter value can contain variables (1.27.0).
</para>

</directive>


<directive name="proxy_max_temp_file_size">
<syntax><value>size</value></syntax>
<default>1024m</default>
<context>http</context>
<context>server</context>
<context>location</context>

<para>
When <link id="proxy_buffering">buffering</link> of responses from the proxied
server is enabled, and the whole response does not fit into the buffers
set by the <link id="proxy_buffer_size"/> and <link id="proxy_buffers"/>
directives, a part of the response can be saved to a temporary file.
This directive sets the maximum <value>size</value> of the temporary file.
The size of data written to the temporary file at a time is set
by the <link id="proxy_temp_file_write_size"/> directive.
</para>

<para>
The zero value disables buffering of responses to temporary files.
</para>

<para>
<note>
This restriction does not apply to responses
that will be <link id="proxy_cache">cached</link>
or <link id="proxy_store">stored</link> on disk.
</note>
</para>

</directive>


<directive name="proxy_method">
<syntax><value>method</value></syntax>
<default/>
<context>http</context>
<context>server</context>
<context>location</context>

<para>
Specifies the HTTP <value>method</value> to use in requests forwarded
to the proxied server instead of the method from the client request.
Parameter value can contain variables (1.11.6).
</para>

</directive>


<directive name="proxy_next_upstream">
<syntax>
    <literal>error</literal> |
    <literal>timeout</literal> |
    <literal>invalid_header</literal> |
    <literal>http_500</literal> |
    <literal>http_502</literal> |
    <literal>http_503</literal> |
    <literal>http_504</literal> |
    <literal>http_403</literal> |
    <literal>http_404</literal> |
    <literal>http_429</literal> |
    <literal>non_idempotent</literal> |
    <literal>off</literal>
    ...</syntax>
<default>error timeout</default>
<context>http</context>
<context>server</context>
<context>location</context>

<para>
Specifies in which cases a request should be passed to the next server:
<list type="tag">

<tag-name><literal>error</literal></tag-name>
<tag-desc>an error occurred while establishing a connection with the
server, passing a request to it, or reading the response header;</tag-desc>

<tag-name><literal>timeout</literal></tag-name>
<tag-desc>a timeout has occurred while establishing a connection with the
server, passing a request to it, or reading the response header;</tag-desc>

<tag-name><literal>invalid_header</literal></tag-name>
<tag-desc>a server returned an empty or invalid response;</tag-desc>

<tag-name><literal>http_500</literal></tag-name>
<tag-desc>a server returned a response with the code 500;</tag-desc>

<tag-name><literal>http_502</literal></tag-name>
<tag-desc>a server returned a response with the code 502;</tag-desc>

<tag-name><literal>http_503</literal></tag-name>
<tag-desc>a server returned a response with the code 503;</tag-desc>

<tag-name><literal>http_504</literal></tag-name>
<tag-desc>a server returned a response with the code 504;</tag-desc>

<tag-name><literal>http_403</literal></tag-name>
<tag-desc>a server returned a response with the code 403;</tag-desc>

<tag-name><literal>http_404</literal></tag-name>
<tag-desc>a server returned a response with the code 404;</tag-desc>

<tag-name><literal>http_429</literal></tag-name>
<tag-desc>a server returned a response with the code 429 (1.11.13);</tag-desc>

<tag-name id="non_idempotent"><literal>non_idempotent</literal></tag-name>
<tag-desc>normally, requests with a
<link url="https://datatracker.ietf.org/doc/html/rfc7231#section-4.2.2">non-idempotent</link>
method
(<literal>POST</literal>, <literal>LOCK</literal>, <literal>PATCH</literal>)
are not passed to the next server
if a request has been sent to an upstream server (1.9.13);
enabling this option explicitly allows retrying such requests;
</tag-desc>

<tag-name><literal>off</literal></tag-name>
<tag-desc>disables passing a request to the next server.</tag-desc>

</list>
</para>

<para>
One should bear in mind that passing a request to the next server is
only possible if nothing has been sent to a client yet.
That is, if an error or timeout occurs in the middle of the
transferring of a response, fixing this is impossible.
</para>

<para>
The directive also defines what is considered an
<link doc="ngx_http_upstream_module.xml" id="max_fails">unsuccessful
attempt</link> of communication with a server.
The cases of <literal>error</literal>, <literal>timeout</literal> and
<literal>invalid_header</literal> are always considered unsuccessful attempts,
even if they are not specified in the directive.
The cases of <literal>http_500</literal>, <literal>http_502</literal>,
<literal>http_503</literal>, <literal>http_504</literal>,
and <literal>http_429</literal> are
considered unsuccessful attempts only if they are specified in the directive.
The cases of <literal>http_403</literal> and <literal>http_404</literal>
are never considered unsuccessful attempts.
</para>

<para>
Passing a request to the next server can be limited by
<link id="proxy_next_upstream_tries">the number of tries</link>
and by <link id="proxy_next_upstream_timeout">time</link>.
</para>

</directive>


<directive name="proxy_next_upstream_timeout">
<syntax><value>time</value></syntax>
<default>0</default>
<context>http</context>
<context>server</context>
<context>location</context>
<appeared-in>1.7.5</appeared-in>

<para>
Limits the time during which a request can be passed to the
<link id="proxy_next_upstream">next server</link>.
The <literal>0</literal> value turns off this limitation.
</para>

</directive>


<directive name="proxy_next_upstream_tries">
<syntax><value>number</value></syntax>
<default>0</default>
<context>http</context>
<context>server</context>
<context>location</context>
<appeared-in>1.7.5</appeared-in>

<para>
Limits the number of possible tries for passing a request to the
<link id="proxy_next_upstream">next server</link>.
The <literal>0</literal> value turns off this limitation.
</para>

</directive>


<directive name="proxy_no_cache">
<syntax><value>string</value> ...</syntax>
<default/>
<context>http</context>
<context>server</context>
<context>location</context>

<para>
Defines conditions under which the response will not be saved to a cache.
If at least one value of the string parameters is not empty and is not
equal to “0” then the response will not be saved:
<example>
proxy_no_cache $cookie_nocache $arg_nocache$arg_comment;
proxy_no_cache $http_pragma    $http_authorization;
</example>
Can be used along with the <link id="proxy_cache_bypass"/> directive.
</para>

</directive>


<directive name="proxy_pass">
<syntax><value>URL</value></syntax>
<default/>
<context>location</context>
<context>if in location</context>
<context>limit_except</context>

<para>
Sets the protocol and address of a proxied server and an optional URI
to which a location should be mapped.
As a protocol, “<literal>http</literal>” or “<literal>https</literal>”
can be specified.
The address can be specified as a domain name or IP address,
and an optional port:
<example>
proxy_pass http://localhost:8000/uri/;
</example>
or as a UNIX-domain socket path specified after the word
“<literal>unix</literal>” and enclosed in colons:
<example>
proxy_pass http://unix:/tmp/backend.socket:/uri/;
</example>
</para>

<para>
If a domain name resolves to several addresses, all of them will be
used in a round-robin fashion.
In addition, an address can be specified as a
<link doc="ngx_http_upstream_module.xml">server group</link>.
</para>

<para>
Parameter value can contain variables.
In this case, if an address is specified as a domain name,
the name is searched among the described server groups,
and, if not found, is determined using a
<link doc="ngx_http_core_module.xml" id="resolver"/>.
</para>

<para>
A request URI is passed to the server as follows:
<list type="bullet" compact="no">

<listitem>
If the <literal>proxy_pass</literal> directive is specified with a URI,
then when a request is passed to the server, the part of a
<link doc="ngx_http_core_module.xml" id="location">normalized</link>
request URI matching the location is replaced by a URI
specified in the directive:
<example>
location /name/ {
    proxy_pass http://127.0.0.1/remote/;
}
</example>
</listitem>

<listitem>
If <literal>proxy_pass</literal> is specified without a URI,
the request URI is passed to the server in the same form
as sent by a client when the original request is processed,
or the full normalized request URI is passed
when processing the changed URI:
<example>
location /some/path/ {
    proxy_pass http://127.0.0.1;
}
</example>
<note>
Before version 1.1.12,
if <literal>proxy_pass</literal> is specified without a URI,
the original request URI might be passed
instead of the changed URI in some cases.
</note>
</listitem>
</list>
</para>

<para>
In some cases, the part of a request URI to be replaced cannot be determined:
<list type="bullet" compact="no">

<listitem>
When location is specified using a regular expression,
and also inside named locations.
<para>
In these cases,
<literal>proxy_pass</literal> should be specified without a URI.
</para>
</listitem>

<listitem>
When the URI is changed inside a proxied location using the
<link doc="ngx_http_rewrite_module.xml" id="rewrite"/> directive,
and this same configuration will be used to process a request
(<literal>break</literal>):
<example>
location /name/ {
    rewrite    /name/([^/]+) /users?name=$1 break;
    proxy_pass http://127.0.0.1;
}
</example>
<para>
In this case, the URI specified in the directive is ignored and
the full changed request URI is passed to the server.
</para>
</listitem>

<listitem>
When variables are used in <literal>proxy_pass</literal>:
<example>
location /name/ {
    proxy_pass http://127.0.0.1$request_uri;
}
</example>
In this case, if URI is specified in the directive,
it is passed to the server as is,
replacing the original request URI.
</listitem>
</list>
</para>

<para>
<link doc="websocket.xml">WebSocket</link> proxying requires special
configuration and is supported since version 1.3.13.
</para>

</directive>


<directive name="proxy_pass_header">
<syntax><value>field</value></syntax>
<default/>
<context>http</context>
<context>server</context>
<context>location</context>

<para>
Permits passing <link id="proxy_hide_header">otherwise disabled</link> header
fields from a proxied server to a client.
</para>

</directive>


<directive name="proxy_pass_request_body">
<syntax><literal>on</literal> | <literal>off</literal></syntax>
<default>on</default>
<context>http</context>
<context>server</context>
<context>location</context>

<para>
Indicates whether the original request body is passed
to the proxied server.
<example>
location /x-accel-redirect-here/ {
    proxy_method GET;
    proxy_pass_request_body off;
    proxy_set_header Content-Length "";

    proxy_pass ...
}
</example>
See also the <link id="proxy_set_header"/> and
<link id="proxy_pass_request_headers"/> directives.
</para>

</directive>


<directive name="proxy_pass_request_headers">
<syntax><literal>on</literal> | <literal>off</literal></syntax>
<default>on</default>
<context>http</context>
<context>server</context>
<context>location</context>

<para>
Indicates whether the header fields of the original request are passed
to the proxied server.
<example>
location /x-accel-redirect-here/ {
    proxy_method GET;
    proxy_pass_request_headers off;
    proxy_pass_request_body off;

    proxy_pass ...
}
</example>
See also the <link id="proxy_set_header"/> and
<link id="proxy_pass_request_body"/> directives.
</para>

</directive>


<directive name="proxy_pass_trailers">
<syntax><literal>on</literal> | <literal>off</literal></syntax>
<default>off</default>
<context>http</context>
<context>server</context>
<context>location</context>
<appeared-in>1.27.2</appeared-in>

<para>
Permits passing trailer fields from a proxied server to a client.
</para>

<para>
<note>
A trailer section in HTTP/1.1 is
<link url="https://datatracker.ietf.org/doc/html/rfc9110#section-6.5.1">explicitly
enabled</link>.
</note>
<example>
location / {
    proxy_http_version 1.1;
    proxy_set_header Connection "te";
    proxy_set_header TE "trailers";
    proxy_pass_trailers on;

    proxy_pass ...
}
</example>
</para>

</directive>


<directive name="proxy_read_timeout">
<syntax><value>time</value></syntax>
<default>60s</default>
<context>http</context>
<context>server</context>
<context>location</context>

<para>
Defines a timeout for reading a response from the proxied server.
The timeout is set only between two successive read operations,
not for the transmission of the whole response.
If the proxied server does not transmit anything within this time,
the connection is closed.
</para>

</directive>


<directive name="proxy_redirect">
<syntax><literal>default</literal></syntax>
<syntax><literal>off</literal></syntax>
<syntax><value>redirect</value> <value>replacement</value></syntax>
<default>default</default>
<context>http</context>
<context>server</context>
<context>location</context>

<para>
Sets the text that should be changed in the <header>Location</header>
and <header>Refresh</header> header fields of a proxied server response.
Suppose a proxied server returned the header field
“<literal>Location: http://localhost:8000/two/some/uri/</literal>”.
The directive
<example>
proxy_redirect http://localhost:8000/two/ http://frontend/one/;
</example>
will rewrite this string to
“<literal>Location: http://frontend/one/some/uri/</literal>”.
</para>

<para>
A server name may be omitted in the <value>replacement</value> string:
<example>
proxy_redirect http://localhost:8000/two/ /;
</example>
then the primary server’s name and port, if different from 80,
will be inserted.
</para>

<para>
The default replacement specified by the <literal>default</literal> parameter
uses the parameters of the
<link doc="ngx_http_core_module.xml" id="location"/> and
<link id="proxy_pass"/> directives.
Hence, the two configurations below are equivalent:
<example>
location /one/ {
    proxy_pass     http://upstream:port/two/;
    proxy_redirect default;
</example>

<example>
location /one/ {
    proxy_pass     http://upstream:port/two/;
    proxy_redirect http://upstream:port/two/ /one/;
</example>
The <literal>default</literal> parameter is not permitted if
<link id="proxy_pass"/> is specified using variables.
</para>

<para>
A <value>replacement</value> string can contain variables:
<example>
proxy_redirect http://localhost:8000/ http://$host:$server_port/;
</example>
</para>

<para>
A <value>redirect</value> can also contain (1.1.11) variables:
<example>
proxy_redirect http://$proxy_host:8000/ /;
</example>
</para>

<para>
The directive can be specified (1.1.11) using regular expressions.
In this case, <value>redirect</value> should either start with
the “<literal>~</literal>” symbol for a case-sensitive matching,
or with the “<literal>~*</literal>” symbols for case-insensitive
matching.
The regular expression can contain named and positional captures,
and <value>replacement</value> can reference them:
<example>
proxy_redirect ~^(http://[^:]+):\d+(/.+)$ $1$2;
proxy_redirect ~*/user/([^/]+)/(.+)$      http://$1.example.com/$2;
</example>
</para>

<para>
Several <literal>proxy_redirect</literal> directives
can be specified on the same level:
<example>
proxy_redirect default;
proxy_redirect http://localhost:8000/  /;
proxy_redirect http://www.example.com/ /;
</example>
If several directives can be applied to
the header fields of a proxied server response,
the first matching directive will be chosen.
</para>

<para>
The <literal>off</literal> parameter cancels the effect
of the <literal>proxy_redirect</literal> directives
inherited from the previous configuration level.
</para>

<para>
Using this directive, it is also possible to add host names to relative
redirects issued by a proxied server:
<example>
proxy_redirect / /;
</example>
</para>

</directive>


<directive name="proxy_request_buffering">
<syntax><literal>on</literal> | <literal>off</literal></syntax>
<default>on</default>
<context>http</context>
<context>server</context>
<context>location</context>
<appeared-in>1.7.11</appeared-in>

<para>
Enables or disables buffering of a client request body.
</para>

<para>
When buffering is enabled, the entire request body is
<link doc="ngx_http_core_module.xml" id="client_body_buffer_size">read</link>
from the client before sending the request to a proxied server.
</para>

<para>
When buffering is disabled, the request body is sent to the proxied server
immediately as it is received.
In this case, the request cannot be passed to the
<link id="proxy_next_upstream">next server</link>
if nginx already started sending the request body.
</para>

<para>
When HTTP/1.1 chunked transfer encoding is used
to send the original request body,
the request body will be buffered regardless of the directive value unless
HTTP/1.1 is <link id="proxy_http_version">enabled</link> for proxying.
</para>

</directive>


<directive name="proxy_send_lowat">
<syntax><value>size</value></syntax>
<default>0</default>
<context>http</context>
<context>server</context>
<context>location</context>

<para>
If the directive is set to a non-zero value, nginx will try to
minimize the number
of send operations on outgoing connections to a proxied server by using either
<c-def>NOTE_LOWAT</c-def> flag of the
<link doc="../events.xml" id="kqueue"/> method,
or the <c-def>SO_SNDLOWAT</c-def> socket option,
with the specified <value>size</value>.
</para>

<para>
This directive is ignored on Linux, Solaris, and Windows.
</para>

</directive>


<directive name="proxy_send_timeout">
<syntax><value>time</value></syntax>
<default>60s</default>
<context>http</context>
<context>server</context>
<context>location</context>

<para>
Sets a timeout for transmitting a request to the proxied server.
The timeout is set only between two successive write operations,
not for the transmission of the whole request.
If the proxied server does not receive anything within this time,
the connection is closed.
</para>

</directive>


<directive name="proxy_set_body">
<syntax><value>value</value></syntax>
<default/>
<context>http</context>
<context>server</context>
<context>location</context>

<para>
Allows redefining the request body passed to the proxied server.
The <value>value</value> can contain text, variables, and their combination.
</para>

</directive>


<directive name="proxy_set_header">
<syntax><value>field</value> <value>value</value></syntax>
<default>Host $proxy_host</default>
<default>Connection close</default>
<context>http</context>
<context>server</context>
<context>location</context>

<para>
Allows redefining or appending fields to the request header
<link id="proxy_pass_request_headers">passed</link> to the proxied server.
The <value>value</value> can contain text, variables, and their combinations.
These directives are inherited from the previous configuration level
if and only if there are no <literal>proxy_set_header</literal> directives
defined on the current level.
By default, only two fields are redefined:
<example>
proxy_set_header Host       $proxy_host;
proxy_set_header Connection close;
</example>
If caching is enabled, the header fields
<header>If-Modified-Since</header>,
<header>If-Unmodified-Since</header>,
<header>If-None-Match</header>,
<header>If-Match</header>,
<header>Range</header>,
and
<header>If-Range</header>
from the original request are not passed to the proxied server.
</para>

<para>
An unchanged <header>Host</header> request header field can be passed like this:
<example>
proxy_set_header Host       $http_host;
</example>
</para>

<para>
However, if this field is not present in a client request header then
nothing will be passed.
In such a case it is better to use the <var>$host</var> variable&mdash;its
value equals the server name in the <header>Host</header> request header
field or the primary server name if this field is not present:
<example>
proxy_set_header Host       $host;
</example>
</para>

<para>
In addition, the server name can be passed together with the port of the
proxied server:
<example>
proxy_set_header Host       $host:$proxy_port;
</example>
</para>

<para>
If the value of a header field is an empty string then this
field will not be passed to a proxied server:
<example>
proxy_set_header Accept-Encoding "";
</example>
</para>

</directive>


<directive name="proxy_socket_keepalive">
<syntax><literal>on</literal> | <literal>off</literal></syntax>
<default>off</default>
<context>http</context>
<context>server</context>
<context>location</context>
<appeared-in>1.15.6</appeared-in>

<para>
Configures the “TCP keepalive” behavior
for outgoing connections to a proxied server.
By default, the operating system’s settings are in effect for the socket.
If the directive is set to the value “<literal>on</literal>”, the
<c-def>SO_KEEPALIVE</c-def> socket option is turned on for the socket.
</para>

</directive>


<directive name="proxy_ssl_certificate">
<syntax><value>file</value></syntax>
<default/>
<context>http</context>
<context>server</context>
<context>location</context>
<appeared-in>1.7.8</appeared-in>

<para>
Specifies a <value>file</value> with the certificate in the PEM format
used for authentication to a proxied HTTPS server.
</para>

<para>
Since version 1.21.0, variables can be used in the <value>file</value> name.
</para>

</directive>


<directive name="proxy_ssl_certificate_key">
<syntax><value>file</value></syntax>
<default/>
<context>http</context>
<context>server</context>
<context>location</context>
<appeared-in>1.7.8</appeared-in>

<para>
Specifies a <value>file</value> with the secret key in the PEM format
used for authentication to a proxied HTTPS server.
</para>

<para>
The value
<literal>engine</literal>:<value>name</value>:<value>id</value>
can be specified instead of the <value>file</value> (1.7.9),
which loads a secret key with a specified <value>id</value>
from the OpenSSL engine <value>name</value>.
</para>

<para>
Since version 1.21.0, variables can be used in the <value>file</value> name.
</para>

</directive>


<directive name="proxy_ssl_ciphers">
<syntax><value>ciphers</value></syntax>
<default>DEFAULT</default>
<context>http</context>
<context>server</context>
<context>location</context>
<appeared-in>1.5.6</appeared-in>

<para>
Specifies the enabled ciphers for requests to a proxied HTTPS server.
The ciphers are specified in the format understood by the OpenSSL library.
</para>

<para>
The full list can be viewed using the
“<command>openssl ciphers</command>” command.
</para>

</directive>


<directive name="proxy_ssl_conf_command">
<syntax><value>name</value> <value>value</value></syntax>
<default/>
<context>http</context>
<context>server</context>
<context>location</context>
<appeared-in>1.19.4</appeared-in>

<para>
Sets arbitrary OpenSSL configuration
<link url="https://www.openssl.org/docs/man1.1.1/man3/SSL_CONF_cmd.html">commands</link>
when establishing a connection with the proxied HTTPS server.
<note>
The directive is supported when using OpenSSL 1.0.2 or higher.
</note>
</para>

<para>
Several <literal>proxy_ssl_conf_command</literal> directives
can be specified on the same level.
These directives are inherited from the previous configuration level
if and only if there are
no <literal>proxy_ssl_conf_command</literal> directives
defined on the current level.
</para>

<para>
<note>
Note that configuring OpenSSL directly
might result in unexpected behavior.
</note>
</para>

</directive>


<directive name="proxy_ssl_crl">
<syntax><value>file</value></syntax>
<default/>
<context>http</context>
<context>server</context>
<context>location</context>
<appeared-in>1.7.0</appeared-in>

<para>
Specifies a <value>file</value> with revoked certificates (CRL)
in the PEM format used to <link id="proxy_ssl_verify">verify</link>
the certificate of the proxied HTTPS server.
</para>

</directive>


<directive name="proxy_ssl_key_log">
<syntax>path</syntax>
<default/>
<context>http</context>
<context>server</context>
<context>location</context>
<appeared-in>1.27.2</appeared-in>

<para>
Enables logging of proxied HTTPS server connection SSL keys
and specifies the path to the key log file.
Keys are logged in the
<link url="https://datatracker.ietf.org/doc/html/draft-ietf-tls-keylogfile">SSLKEYLOGFILE</link>
format compatible with Wireshark.
</para>

<para>
<note>
This directive is available as part of our
<commercial_version>commercial subscription</commercial_version>.
</note>
</para>

</directive>


<directive name="proxy_ssl_name">
<syntax><value>name</value></syntax>
<default>$proxy_host</default>
<context>http</context>
<context>server</context>
<context>location</context>
<appeared-in>1.7.0</appeared-in>

<para>
Allows overriding the server name used to
<link id="proxy_ssl_verify">verify</link>
the certificate of the proxied HTTPS server and to be
<link id="proxy_ssl_server_name">passed through SNI</link>
when establishing a connection with the proxied HTTPS server.
</para>

<para>
By default, the host part of the <link id="proxy_pass"/> URL is used.
</para>

</directive>


<directive name="proxy_ssl_password_file">
<syntax><value>file</value></syntax>
<default/>
<context>http</context>
<context>server</context>
<context>location</context>
<appeared-in>1.7.8</appeared-in>

<para>
Specifies a <value>file</value> with passphrases for
<link id="proxy_ssl_certificate_key">secret keys</link>
where each passphrase is specified on a separate line.
Passphrases are tried in turn when loading the key.
</para>

</directive>


<directive name="proxy_ssl_protocols">
<syntax>
    [<literal>SSLv2</literal>]
    [<literal>SSLv3</literal>]
    [<literal>TLSv1</literal>]
    [<literal>TLSv1.1</literal>]
    [<literal>TLSv1.2</literal>]
    [<literal>TLSv1.3</literal>]</syntax>
<default>TLSv1 TLSv1.1 TLSv1.2 TLSv1.3</default>
<context>http</context>
<context>server</context>
<context>location</context>
<appeared-in>1.5.6</appeared-in>

<para>
Enables the specified protocols for requests to a proxied HTTPS server.
</para>

<para>
<note>
The <literal>TLSv1.3</literal> parameter is used by default
since 1.23.4.
</note>
</para>

</directive>


<directive name="proxy_ssl_server_name">
<syntax><literal>on</literal> | <literal>off</literal></syntax>
<default>off</default>
<context>http</context>
<context>server</context>
<context>location</context>
<appeared-in>1.7.0</appeared-in>

<para>
Enables or disables passing of the server name through
<link url="http://en.wikipedia.org/wiki/Server_Name_Indication">TLS
Server Name Indication extension</link> (SNI, RFC 6066)
when establishing a connection with the proxied HTTPS server.
</para>

</directive>


<directive name="proxy_ssl_session_reuse">
<syntax><literal>on</literal> | <literal>off</literal></syntax>
<default>on</default>
<context>http</context>
<context>server</context>
<context>location</context>

<para>
Determines whether SSL sessions can be reused when working with
the proxied server.
If the errors
“<literal>SSL3_GET_FINISHED:digest check failed</literal>”
appear in the logs, try disabling session reuse.
</para>

</directive>


<directive name="proxy_ssl_trusted_certificate">
<syntax><value>file</value></syntax>
<default/>
<context>http</context>
<context>server</context>
<context>location</context>
<appeared-in>1.7.0</appeared-in>

<para>
Specifies a <value>file</value> with trusted CA certificates in the PEM format
used to <link id="proxy_ssl_verify">verify</link>
the certificate of the proxied HTTPS server.
</para>

</directive>


<directive name="proxy_ssl_verify">
<syntax><literal>on</literal> | <literal>off</literal></syntax>
<default>off</default>
<context>http</context>
<context>server</context>
<context>location</context>
<appeared-in>1.7.0</appeared-in>

<para>
Enables or disables verification of the proxied HTTPS server certificate.
</para>

</directive>


<directive name="proxy_ssl_verify_depth">
<syntax><value>number</value></syntax>
<default>1</default>
<context>http</context>
<context>server</context>
<context>location</context>
<appeared-in>1.7.0</appeared-in>

<para>
Sets the verification depth in the proxied HTTPS server certificates chain.
</para>

</directive>


<directive name="proxy_store">
<syntax>
    <literal>on</literal> |
    <literal>off</literal> |
    <value>string</value></syntax>
<default>off</default>
<context>http</context>
<context>server</context>
<context>location</context>

<para>
Enables saving of files to a disk.
The <literal>on</literal> parameter saves files with paths
corresponding to the directives
<link doc="ngx_http_core_module.xml" id="alias"/> or
<link doc="ngx_http_core_module.xml" id="root"/>.
The <literal>off</literal> parameter disables saving of files.
In addition, the file name can be set explicitly using the
<value>string</value> with variables:
<example>
proxy_store /data/www$original_uri;
</example>
</para>

<para>
The modification time of files is set according to the received
<header>Last-Modified</header> response header field.
The response is first written to a temporary file,
and then the file is renamed.
Starting from version 0.8.9, temporary files and the persistent store
can be put on different file systems.
However, be aware that in this case a file is copied
across two file systems instead of the cheap renaming operation.
It is thus recommended that for any given location both saved files and a
directory holding temporary files, set by the <link id="proxy_temp_path"/>
directive, are put on the same file system.
</para>

<para>
This directive can be used to create local copies of static unchangeable
files, e.g.:
<example>
location /images/ {
    root               /data/www;
    error_page         404 = /fetch$uri;
}

location /fetch/ {
    internal;

    proxy_pass         http://backend/;
    proxy_store        on;
    proxy_store_access user:rw group:rw all:r;
    proxy_temp_path    /data/temp;

    alias              /data/www/;
}
</example>
</para>

<para>
or like this:
<example>
location /images/ {
    root               /data/www;
    error_page         404 = @fetch;
}

location @fetch {
    internal;

    proxy_pass         http://backend;
    proxy_store        on;
    proxy_store_access user:rw group:rw all:r;
    proxy_temp_path    /data/temp;

    root               /data/www;
}
</example>
</para>

</directive>


<directive name="proxy_store_access">
<syntax><value>users</value>:<value>permissions</value> ...</syntax>
<default>user:rw</default>
<context>http</context>
<context>server</context>
<context>location</context>

<para>
Sets access permissions for newly created files and directories, e.g.:
<example>
proxy_store_access user:rw group:rw all:r;
</example>
</para>

<para>
If any <literal>group</literal> or <literal>all</literal> access permissions
are specified then <literal>user</literal> permissions may be omitted:
<example>
proxy_store_access group:rw all:r;
</example>
</para>

</directive>


<directive name="proxy_temp_file_write_size">
<syntax><value>size</value></syntax>
<default>8k|16k</default>
<context>http</context>
<context>server</context>
<context>location</context>

<para>
Limits the <value>size</value> of data written to a temporary file
at a time, when buffering of responses from the proxied server
to temporary files is enabled.
By default, <value>size</value> is limited by two buffers set by the
<link id="proxy_buffer_size"/> and <link id="proxy_buffers"/> directives.
The maximum size of a temporary file is set by the
<link id="proxy_max_temp_file_size"/> directive.
</para>

</directive>


<directive name="proxy_temp_path">
<syntax>
    <value>path</value>
    [<value>level1</value>
    [<value>level2</value>
    [<value>level3</value>]]]</syntax>
<default>proxy_temp</default>
<context>http</context>
<context>server</context>
<context>location</context>

<para>
Defines a directory for storing temporary files
with data received from proxied servers.
Up to three-level subdirectory hierarchy can be used underneath the specified
directory.
For example, in the following configuration
<example>
proxy_temp_path /spool/nginx/proxy_temp 1 2;
</example>
a temporary file might look like this:
<example>
/spool/nginx/proxy_temp/<emphasis>7</emphasis>/<emphasis>45</emphasis>/00000123<emphasis>457</emphasis>
</example>
</para>

<para>
See also the <literal>use_temp_path</literal> parameter of the
<link id="proxy_cache_path"/> directive.
</para>

</directive>

</section>


<section id="variables" name="Embedded Variables">

<para>
The <literal>ngx_http_proxy_module</literal> module supports embedded variables
that can be used to compose headers using the
<link id="proxy_set_header"/> directive:
<list type="tag">

<tag-name id="var_proxy_host"><var>$proxy_host</var></tag-name>
<tag-desc>name and port of a proxied server as specified in the
<link id="proxy_pass"/> directive;</tag-desc>

<tag-name id="var_proxy_port"><var>$proxy_port</var></tag-name>
<tag-desc>port of a proxied server as specified in the
<link id="proxy_pass"/> directive, or the protocol’s default port;</tag-desc>

<tag-name id="var_proxy_add_x_forwarded_for">
<var>$proxy_add_x_forwarded_for</var></tag-name>
<tag-desc>the <header>X-Forwarded-For</header> client request header field
with the <var>$remote_addr</var> variable appended to it, separated by a comma.
If the <header>X-Forwarded-For</header> field is not present in the client
request header, the <var>$proxy_add_x_forwarded_for</var> variable is equal
to the <var>$remote_addr</var> variable.</tag-desc>
</list>
</para>

</section>

</module>
